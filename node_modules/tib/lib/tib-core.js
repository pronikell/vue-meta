'use strict';

require('path');
require('hable');
require('signal-exit');
require('os');
require('child_process');
require('tree-kill');
const index = require('./tib-index.js');
require('vue-template-compiler');
const webpage = require('./tib-webpage.js');
require('crypto');
require('fs');
require('util');
require('glob');
require('webpack');
require('@babel/core');
require('@babel/parser');
require('http');
const chrome = require('./tib-chrome.js');

class PuppeteerWebpage extends webpage.Webpage {
  async open(url, readyCondition = 'body') {
    this.page = await this.driver.newPage();

    await this.browser.callHook('page:created', this.page);

    await this.page.goto(url);

    if (readyCondition) {
      let waitFn = 'waitForSelector';
      if (typeof readyCondition === 'number') {
        waitFn = 'waitForTimeout';
      } else if (typeof readyCondition === 'function') {
        waitFn = 'waitForFunction';
      }

      await this.page[waitFn](readyCondition);
    }

    return this.returnProxy()
  }

  runScript(pageFunction, ...args) {
    let parsedFn;
    if (typeof pageFunction === 'function') {
      parsedFn = webpage.parseFunction(pageFunction, args, this.getBabelPresetOptions());
    } else {
      parsedFn = pageFunction;
    }

    // It would be bettter to return undefined when no el exists,
    // but selenium always returns null for undefined so better to keep
    // the return value consistent
    return this.page.evaluate(
      /* istanbul ignore next */
      function (fn, ...args) {
        return (new (Function.bind.apply(Function, fn))()).apply(null, [].concat(args))
      },
      [null, ...parsedFn.args, parsedFn.body],
      ...args
    )
  }

  getHtml() {
    /* istanbul ignore next */
    const pageFn = () => window.document.documentElement.outerHTML;
    return this.page.evaluate(pageFn)
  }

  getTitle() {
    return this.page.title()
  }
}

class PuppeteerCoreBrowser extends index.Browser {
  async _loadDependencies() {
    super._loadDependencies();

    if (!PuppeteerCoreBrowser.core) {
      PuppeteerCoreBrowser.core = await this.loadDependency('puppeteer-core');
    }
  }

  setHeadless() {
    super.setHeadless();
    this.config.browserArguments.push('--headless');
  }

  setLogLevel(types) {
    const typeMap = {
      warning: 'warn'
    };

    if (types && typeof types === 'string') {
      types = [types];
    }

    this.hook('page:created', (page) => {
      /* eslint-disable no-console */
      page.on('console', (msg) => {
        const msgType = msg.type();
        let type = typeMap[msgType] || msgType;
        if (!types || types.includes(msgType) || types.includes(type)) {
          if (!console[type]) {
            console.warn(`Unknown console type ${type}`);
            type = 'log';
          }
          console[type](msg.text());
        }
      });
      /* eslint-enable no-console */
    });
  }

  async _start(capabilities, ...args) {
    // https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions
    const launchOptions = {
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        ...this.config.browserArguments,
        ...args
      ],
      ...capabilities
    };

    if (this.constructor.name === 'PuppeteerCoreBrowser') {
      let executablePath = process.env.PUPPETEER_EXECUTABLE_PATH;
      if (!executablePath) {
        const detector = new chrome.ChromeDetector();
        executablePath = detector.detect();
      }

      if (!executablePath) {
        throw new index.BrowserError(this, 'Could not find a Chrome executable')
      }

      launchOptions.executablePath = executablePath;
    }

    this.driver = await PuppeteerCoreBrowser.core.launch(launchOptions);
  }

  async _close() {
    if (!this.driver) {
      return
    }

    await this.driver.close();
  }

  _page(url, readyCondition) {
    const page = new PuppeteerWebpage(this);
    return page.open(url, readyCondition)
  }
}

exports.default = PuppeteerCoreBrowser;
