'use strict';

require('path');
const index = require('./tib-index.js');
const vueTemplateCompiler = require('vue-template-compiler');
require('crypto');
require('webpack');
const core = require('@babel/core');
const parser = require('@babel/parser');

function getDefaultHtmlCompiler() {
  return html => vueTemplateCompiler.compile(html).ast
}

const fnCache = {};

function parseFunction(fn, args, presetOptions) {
  if (arguments.length === 2) {
    presetOptions = args || {};
    args = undefined;
  }

  if (typeof fn !== 'function') {
    throw new index.BrowserError(`parseFunction expects the first argument to be a function, received '${typeof fn}' instead`)
  }

  const fnString = fn.toString();
  const cacheKey = index.createCacheKey(fnString, presetOptions);

  if (fnCache[cacheKey] && fnCache[cacheKey]) {
    return fnCache[cacheKey]
  }

  const parsed = {};
  let ast = parser.parseExpression(fnString);
  parsed.args = ast.params.map(p => p.name);

  ast = ast.body;

  /* transform can only transform a program and a program is an Array of
   * Statements.
   * The body of an arrow function like 'arg => arg' does not
   * contain a Statement, so we add a block & return statement in that case.
   * The return statement is needed later when we create a new Function and the
   * block statement helps so we can (almost) always call slice(1, -1) below to
   * retrieve the real function body
   */
  if (!ast.type.includes('Statement')) {
    ast = core.types.blockStatement([core.types.returnStatement(ast)]);
  }

  const transpiled = core.transformFromAstSync(
    core.types.file(core.types.program([ast])),
    undefined,
    {
      sourceType: 'script',
      presets: [
        ['@babel/preset-env', presetOptions]
      ]
    }
  );

  if (transpiled.code[0] === '{') {
    // remove block statement needed to transform & trim block whitespace
    parsed.body = transpiled.code.slice(1, -1).trim();
  } else {
    /* istanbul ignore next */
    parsed.body = transpiled.code;
  }

  fnCache[cacheKey] = parsed;
  return parsed
}

class Webpage {
  constructor(browser) {
    index.abstractGuard('Webpage', new.target);

    if (!browser || !browser.driver) {
      throw new index.BrowserError(this, 'Browser driver is required, has the browser been started succesfully?')
    }

    this.browser = browser;
    this.driver = this.browser.driver;
    this.userExtended = {};
  }

  returnProxy() {
    return new Proxy(this, {
      get(target, property) {
        target.browser.callHook('webpage:property', property);

        if (target.userExtended && target.userExtended[property]) {
          return target.userExtended[property]
        }

        if (target[property]) {
          return target[property]
        }

        if (target.page && target.page[property]) {
          return target.page[property]
        }

        return target.driver[property]
      }
    })
  }

  extend(extendWith = {}) {
    this.userExtended = extendWith;
  }

  getHtmlCompiler() {
    if (this._htmlCompiler) {
      return this._htmlCompiler
    }

    let htmlCompiler;
    if (typeof this.driver.htmlCompiler === 'function') {
      htmlCompiler = this.driver.htmlCompiler;
    }

    if (!htmlCompiler || typeof htmlCompiler !== 'function') {
      htmlCompiler = getDefaultHtmlCompiler();
    }

    this._htmlCompiler = htmlCompiler;
    return this._htmlCompiler
  }

  getBabelPresetOptions({ polyfills = false } = {}) {
    const presetOptions = {};

    const browser = this.browser.getBrowser();
    const version = this.browser.getBrowserVersion();

    if (browser && version) {
      presetOptions.targets = {
        [browser]: version
      };
    }

    if (polyfills) {
      presetOptions.useBuiltIns = polyfills === true ? 'usage' : polyfills;
    }

    return presetOptions
  }

  getHtml() {}

  runScript(...args) {}

  runAsyncScript(...args) {
    return this.runScript(...args)
  }

  async getElement(selector) {
    const html = await this.getElementHtml(selector);
    return this.getHtmlCompiler()(html)
  }

  async getElements(selector) {
    const htmls = await this.getElementsHtml(selector);
    const htmlCompiler = this.getHtmlCompiler();
    return htmls.map(html => htmlCompiler(html))
  }

  getElementFromPage(pageFunction, selector, ...args) {
    const parsedFn = parseFunction(pageFunction, this.getBabelPresetOptions());

    // It would be bettter to return undefined when no el exists,
    // but selenium always returns null for undefined so better to keep
    // the return value consistent

    /* eslint-disable no-var */
    return this.runScript(
      /* istanbul ignore next */
      function (selector, fn, args) {
        var el = document.querySelector(selector);
        if (!el) {
          return null
        }

        return (new (Function.bind.apply(Function, fn))()).apply(null, [el].concat(args))
      },
      selector,
      [null, ...parsedFn.args, parsedFn.body],
      args
    )
    /* eslint-enable no-var */
  }

  getElementsFromPage(pageFunction, selector, ...args) {
    const parsedFn = parseFunction(pageFunction, this.getBabelPresetOptions());

    /* eslint-disable no-var */
    return this.runScript(
      /* istanbul ignore next */
      function (selector, fn, args) {
        var els = document.querySelectorAll(selector);
        return (new (Function.bind.apply(Function, fn))()).apply(null, [Array.prototype.slice.call(els)].concat(args))
      },
      selector,
      [null, ...parsedFn.args, parsedFn.body],
      args
    )
    /* eslint-enable no-var */
  }

  getElementCount(selector) {
    /* istanbul ignore next */
    const pageFn = els => els.length;
    return this.getElementsFromPage(pageFn, selector)
  }

  getElementHtml(selector) {
    /* istanbul ignore next */
    const pageFn = el => el.outerHTML;
    return this.getElementFromPage(pageFn, selector)
  }

  getElementsHtml(selector) {
    /* istanbul ignore next */
    const pageFn = els => els.map(el => el.outerHTML);
    return this.getElementsFromPage(pageFn, selector)
  }

  getAttribute(selector, attribute) {
    /* istanbul ignore next */
    const pageFn = (el, attribute) => el.getAttribute(attribute);
    return this.getElementFromPage(pageFn, selector, attribute)
  }

  getAttributes(selector, attribute) {
    /* istanbul ignore next */
    const pageFn = (els, attribute) => els.map(el => el.getAttribute(attribute));
    return this.getElementsFromPage(pageFn, selector, attribute)
  }

  getText(selector, trim) {
    /* istanbul ignore next */
    const pageFn = el => el.textContent;
    return this.getElementFromPage(pageFn, selector).then(text => (trim ? text.trim() : text))
  }

  getTexts(selector, trim) {
    /* istanbul ignore next */
    const pageFn = els => els.map(el => el.textContent);
    return this.getElementsFromPage(pageFn, selector).then(texts => (trim ? texts.map(t => t.trim()) : texts))
  }

  clickElement(selector) {
    /* istanbul ignore next */
    const pageFn = el => el.click();
    return this.getElementFromPage(pageFn, selector)
  }
}

exports.Webpage = Webpage;
exports.parseFunction = parseFunction;
