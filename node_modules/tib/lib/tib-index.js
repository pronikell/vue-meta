'use strict';

const path = require('path');
const Hookable = require('hable');
const onExit = require('signal-exit');
const os$1 = require('os');
const child_process = require('child_process');
const kill = require('tree-kill');
require('vue-template-compiler');
const crypto = require('crypto');
const fs = require('fs');
const util = require('util');
const Glob = require('glob');
const webpack = require('webpack');
require('@babel/core');
require('@babel/parser');
const http = require('http');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const Hookable__default = /*#__PURE__*/_interopDefaultLegacy(Hookable);
const onExit__default = /*#__PURE__*/_interopDefaultLegacy(onExit);
const os__default = /*#__PURE__*/_interopDefaultLegacy(os$1);
const kill__default = /*#__PURE__*/_interopDefaultLegacy(kill);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
const Glob__default = /*#__PURE__*/_interopDefaultLegacy(Glob);
const webpack__default = /*#__PURE__*/_interopDefaultLegacy(webpack);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);

// https://www.browserstack.com/automate/node#configure-capabilities
// https://wiki.saucelabs.com/display/DOCS/Platform+Configurator

const browsers = [
  'chrome',
  'firefox',
  'ie',
  'jsdom',
  'edge',
  'safari'
];

const browserOptions = [
  'headless',
  'xvfb',
  'staticserver'
];

const drivers = [
  'puppeteer',
  'puppeteer-core',
  'selenium'
];

const providers = [
  'browserstack',
  'saucelabs'
];

const browserVariants = {
  local: ['browserstack'],
  core: ['puppeteer']
};

const os = [
  'windows',
  'linux',
  'mac',
  'macos',
  'macosx',
  'osx',
  'android',
  'ios'
];

function getBrowserConfigFromString(browserString) {
  const browserConfig = {};

  browserString
    .split('/')
    .filter(s => !!s)
    .map(s => s.toLowerCase()
      // replace first occurence with =
      // -> Chrome 39 => chrome=39
      // -> Mac OS X=High Sierra => Mac OS X=High Sierra
      .replace(/([\s:])/, (m, $1, o, s) => (s.includes('=') ? $1 : '='))
    )
    .forEach((s) => {
      let [key, value] = s.split('=', 2); // eslint-disable-line prefer-const
      key = key.replace(/\s+/, '');

      if (browsers.includes(key)) {
        browserConfig.browser = key;

        if (value) {
          browserConfig.browserVersion = value.replace(/\s+/g, '');
        }
        return
      }

      if (browserOptions.includes(key)) {
        browserConfig[key] = typeof value === 'undefined' ? true : value;
        return
      }

      if (os.includes(key)) {
        browserConfig.os = key;

        if (value) {
          browserConfig.osVersion = value;
        }
        return
      }

      if (drivers.includes(key)) {
        browserConfig.driver = key;
        return
      }

      if (providers.includes(key)) {
        browserConfig.provider = key;
        return
      }

      if (browserVariants[key]) {
        browserConfig.browserVariant = key;
        return
      }

      if (key === 'device') {
        browserConfig.device = value;
        return
      }

      if (!value) {
        const screenResolution = key.split(/(\d+)x(\d+)/i);
        if (screenResolution && screenResolution.length > 1) {
          browserConfig.window = {
            width: parseInt(screenResolution[1]),
            height: parseInt(screenResolution[2])
          };
        }
      }
    });

  return browserConfig
}

function getBrowserImportFromConfig(browserConfig) {
  const importPath = [];

  if (browserConfig.browser) {
    importPath.push(browserConfig.browser);
  }

  if (browserConfig.driver && !browserConfig.provider) {
    importPath.push(browserConfig.driver);
  }

  if (browserConfig.provider) {
    importPath.push(browserConfig.provider);
  }

  if (browserConfig.browserVariant) {
    importPath.push(browserConfig.browserVariant);
  }

  return importPath.join('/')
}

const md5sum = str => crypto.createHash('md5').update(str).digest('hex');

const readDir = util__default['default'].promisify(fs__default['default'].readdir);
const readFile = util__default['default'].promisify(fs__default['default'].readFile);
const glob = util__default['default'].promisify(Glob__default['default']);

function exists(p) {
  return new Promise((resolve, reject) => {
    fs__default['default'].access(p, fs__default['default'].constants.F_OK, (err) => {
      if (err) {
        resolve(false);
        return
      }

      resolve(true);
    });
  })
}

function stats(p) {
  return new Promise((resolve, reject) => {
    fs__default['default'].stat(p, (err, stats) => {
      if (err) {
        resolve(false);
        return
      }

      resolve(stats);
    });
  })
}

function requireResolve(path) {
  /* istanbul ignore next */
  return require.resolve(path)
}

let nodeModulesPath;

async function checkNodeModulesPath(modulesPath) {
  const pathExists = await exists(modulesPath);

  if (pathExists) {
    nodeModulesPath = modulesPath;
    return true
  }

  return false
}

async function findNodeModulesPath(refresh) {
  if (nodeModulesPath && !refresh) {
    return nodeModulesPath
  }

  let modulesPath = path__default['default'].resolve(__dirname, '../../..', 'node_modules');
  if (await checkNodeModulesPath(modulesPath)) {
    return nodeModulesPath
  }

  modulesPath = path__default['default'].resolve('./node_modules');
  if (await checkNodeModulesPath(modulesPath)) {
    return nodeModulesPath
  }

  const hablePath = requireResolve('hable/package.json');
  modulesPath = path__default['default'].dirname(path__default['default'].dirname(hablePath));
  if (await checkNodeModulesPath(modulesPath)) {
    return nodeModulesPath
  }

  modulesPath = __dirname;
  while (modulesPath.length > 1) {
    const tryPath = path__default['default'].join(modulesPath, 'node_modules');
    modulesPath = path__default['default'].dirname(modulesPath);

    if (await checkNodeModulesPath(tryPath)) {
      modulesPath = tryPath;
      break
    }
  }

  if (modulesPath.length <= 1) {
    modulesPath = '';
  }

  nodeModulesPath = modulesPath;
  return modulesPath
}

function createCacheKey(fn, opts) {
  if (typeof opts !== 'string') {
    opts = JSON.stringify(opts);
  }

  return md5sum(`${fn}-x-${opts}`)
}

async function getCachePath(filePath = '') {
  const modulesPath = await findNodeModulesPath();
  return path__default['default'].join(modulesPath, '.cache', 'tib', filePath)
}

class BrowserError extends Error {
  constructor(classInstance, message, ...params) {
    let className;
    if (!message) {
      message = classInstance;
      className = 'BrowserError';
    } else if (typeof classInstance === 'object') {
      className = classInstance.constructor.name;
    } else if (typeof classInstance === 'string') {
      className = classInstance;
    }

    // Pass remaining arguments (including vendor specific ones) to parent constructor
    super(`${className}: ${message}`, ...params);

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, BrowserError);
    }
  }
}

const camelCase = str => str.replace(/(^|[-_.\s]+)(.)/g, (m, $1, $2, offset) => !offset ? $2.toLowerCase() : $2.toUpperCase());

function abstractGuard(className, { name } = {}) {
  if (className === name) {
    throw new BrowserError(`Do not use abstract class '${className}' directly`)
  }
}

function isMockedFunction(fn, fnName) {
  return fn.name !== fnName
}

async function loadDependency(dependency) {
  try {
    const module = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(dependency)); }).then(m => m.default || m);
    return module
  } catch (e) {
    throw new BrowserError(`Could not import the required dependency '${dependency}'
(error: ${e.message})

Please install the dependency with:
$ npm install ${dependency}
or
$ yarn add ${dependency}
    `)
  }
}

async function createPageFunctions(page, sourceFiles, babelPresets) {
  const pageFunctions = {};

  if (!sourceFiles) {
    return pageFunctions
  }

  if (typeof sourceFiles === 'string') {
    sourceFiles = await glob(sourceFiles);
  }

  for (let file of sourceFiles) {
    let fnName;
    if (Array.isArray(file)) {
      [file, fnName] = file;
    } else {
      fnName = camelCase(path__default['default'].basename(file, '.js'));
    }

    if (pageFunctions[fnName]) {
      // eslint-disable-next-line no-console
      console.warn(`A page function with name '${fnName}' already exists, the previous one will be overwritten`);
    }

    pageFunctions[fnName] = async (...args) => {
      const body = await getPageFunctionBody(fnName, file, babelPresets);

      return page.runAsyncScript({
        args: [],
        body: `${body} return (pageFn.${fnName} || pageFn.default).apply(null, arguments)`
      }, ...args)
    };
  }

  return pageFunctions
}

async function getPageFunctionBody(fnName, filePath, babelPresets) {
  const cacheKey = createCacheKey(filePath, babelPresets);
  const cacheFile = `${fnName}-${cacheKey}.js`;
  const cachePath = await getCachePath(cacheFile);
  let cacheValid = await exists(cachePath);

  if (cacheValid) {
    const { mtime: fileModified } = await stats(filePath);
    const { mtime: cacheModified } = await stats(cachePath);

    cacheValid = cacheModified > fileModified;
  }

  if (!cacheValid) {
    // transpile page function
    await compilePageFunction({
      name: 'pageFn',
      filePath,
      cachePath,
      babelPresets
    });
  }

  const fnBody = await readFile(cachePath, { encoding: 'utf8' });
  return fnBody
}

async function compilePageFunction({ babelPresets, ...config }) {
  let babelOptions;

  if (babelPresets) {
    babelOptions = {
      presets: [
        ['@babel/preset-env', babelPresets]
      ]
    };
  } else {
    babelOptions = {
      babelrcRoots: [
        '.',
        path__default['default'].resolve(await findNodeModulesPath(), '..')
      ]
    };
  }

  config.babelOptions = babelOptions;

  return new Promise((resolve, reject) => {
    const webpackConfig = createWebpackConfig(config);

    webpack__default['default'](webpackConfig, (err, stats) => {
      /* istanbul ignore next */
      if (err) {
        reject(err);
        return
      }

      if (stats.hasErrors()) {
        const [err] = stats.compilation.errors;
        reject(err);
        return
      }

      resolve(stats);
    });
  })
}
function createWebpackConfig({
  name,
  filePath,
  cachePath,
  babelOptions = {}
}) {
  return {
    mode: 'production',
    entry: filePath,
    output: {
      path: path__default['default'].dirname(cachePath),
      filename: path__default['default'].basename(cachePath),
      library: name,
      libraryTarget: 'var'
    },
    plugins: [
      new webpack__default['default'].optimize.LimitChunkCountPlugin({
        maxChunks: 1
      })
    ],
    module: {
      rules: [
        {
          test: /\.js$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: babelOptions
          }
        }
      ]
    }
  }
}

// TODO: add more test framework checks like sinon?
function disableTimers() {
  // find Jest fingerprint
  if (process.env.JEST_WORKER_ID) {
    try {
      jest.useFakeTimers();
    } catch (e) {
      /* istanbul ignore next */
      throw new BrowserError(`Enabling fake timers failed: ${e.message}`)
    }
  }
}

function enableTimers() {
  // find Jest fingerprint
  if (process.env.JEST_WORKER_ID) {
    try {
      // call useFakeTimers first as it seems there is no way to determine
      // if fake timers are used at all and otherwise runOnlyPendingTimers
      // will fail with a warning from within Jest
      // -> Disabled because we probably dont care about pending timers
      // jest.useFakeTimers()
      // jest.runOnlyPendingTimers()
      jest.useRealTimers();
    } catch (e) {
      /* istanbul ignore next */
      throw new BrowserError(`Enabling real timers failed: ${e.message}`)
    }
  }
}

const consola = console; // eslint-disable-line no-console

const supportedPlatforms = [
  'linux',
  'freebsd',
  'openbsd'
];

class Xvfb {
  static load(browser) {
    if (!browser.config.xvfb) {
      return
    }

    Xvfb.isSupported(true);

    const browserConfig = browser.config.browserConfig;
    if (browserConfig && browserConfig.window) {
      if (typeof browser.config.xvfb !== 'object') {
        browser.config.xvfb = { args: [] };
      }

      browser.config.xvfb.args.push(`-screen 0 ${browserConfig.window.width}x${browserConfig.window.height}x24`);
    }

    const config = {
      quiet: browser.config.quiet,
      ...browser.config.xvfb
    };

    browser.hook('start:before', () => Xvfb.start(config));
    browser.hook('close:after', Xvfb.stop);
  }

  static isSupported(failWhenNot) {
    const platform = os__default['default'].platform();
    const supported = supportedPlatforms.includes(platform);

    if (!supported && failWhenNot) {
      throw new BrowserError(`Xvfb is not supported on ${platform} platforms`)
    }

    return supported
  }

  static isRunning() {
    return !!Xvfb.process && Xvfb.process.connected && !Xvfb.closed
  }

  static start({ displayNum = 99, args = [], quiet } = {}) {
    Xvfb.isSupported(true);
    Xvfb.closed = false;

    if (Xvfb.isRunning()) {
      return
    }

    args = (Array.isArray(args) && args) || [];

    const display = `:${displayNum}`;
    args.unshift(display);
    args.unshift('Xvfb');

    Xvfb.process = child_process.spawn('command', args, {
      shell: true,
      stdio: [
        'ignore',
        'ignore',
        'pipe'
      ]
    });

    // set DISPLAY env
    process.env.DISPLAY = display;

    let stderr = '';
    Xvfb.process.stderr.on('data', data => (stderr += `${data}`));

    Xvfb.process.on('error', (err) => {
      Xvfb.closed = true;

      if (err && err.code === 'ENOENT') {
        throw new BrowserError('Xvfb not found, please make sure Xvfb is installed')
      }
    });

    Xvfb.process.on('close', (code, signal) => {
      Xvfb.closed = true;

      if (code === 1) {
        const error = stderr.match(/\(EE\) (?!\(EE\))(.+?)$/m)[1] || stderr;
        if (stderr.includes('already active for display')) {
          if (!quiet) {
            console.warn(`Xvfb: ${error}`, Xvfb.process.pid); // eslint-disable-line no-console
          }
          return
        }

        throw new BrowserError(`Failed to start Xvfb${error ? ', ' : ''}${error}`)
      }
    });

    onExit__default['default'](() => Xvfb.stop());
  }

  static stop() {
    if (!Xvfb.process || Xvfb.closed) {
      return
    }

    kill__default['default'](Xvfb.process.pid);

    // enable timers if they where faked by a test framework
    enableTimers();

    let closeTimeout;
    const waitTimeout = new Promise((resolve) => {
      closeTimeout = setTimeout(() => {
        consola.warn('Timeout: Xvfb did not exit after 3s');
        resolve();
      }, 3000);
      closeTimeout.unref();
    });

    const waitClosed = new Promise((resolve) => {
      const closeInterval = setInterval(() => {
        if (Xvfb.closed) {
          clearTimeout(closeTimeout);
          clearInterval(closeInterval);
          resolve();
        }
      }, 50);
    });

    return Promise.race([waitClosed, waitTimeout])
  }
}

const consola$1 = console; // eslint-disable-line no-console

let PID;

class BrowserStackLocal {
  static async loadDriver() {
    if (BrowserStackLocal.driver) {
      return
    }

    const browserstack = await loadDependency('browserstack-local');
    BrowserStackLocal.driver = new browserstack.Local();
  }

  static async start(config = {}) {
    // TODO: support webserver
    if (!config.folder && config.folder !== false) {
      config.folder = path__default['default'].resolve(process.cwd());
    }

    await BrowserStackLocal.loadDriver();

    // util.promisify doesnt work due to this binding and
    // .bind(local) didnt work either
    return new Promise((resolve, reject) => {
      BrowserStackLocal.driver.start(config, (error) => {
        if (error) {
          reject(error);
        }

        onExit__default['default'](() => BrowserStackLocal.stop());

        PID = BrowserStackLocal.driver.pid;
        resolve(PID);
      });
    })
  }

  static stop(pid) {
    pid = pid || (BrowserStackLocal.driver && BrowserStackLocal.driver.pid) || PID;

    if (!BrowserStackLocal.driver || !pid) {
      consola$1.warn('Stop called but browserstack-local was not started');
      return
    }

    return new Promise((resolve, reject) => {
      // local.stop is buggy, it doesnt kill anything and takes forever
      // after looking at the local.stop implementation tree-kill does
      // practically the same
      kill__default['default'](pid, 'SIGTERM', (error) => {
        if (error) {
          /* istanbul ignore next */
          reject(error);
        }

        resolve();
      });
    })
  }
}

class StaticServer {
  static async loadDependencies() {
    if (StaticServer.serveStatic) {
      return
    }

    StaticServer.serveStatic = await loadDependency('serve-static');
    StaticServer.finalhandler = await loadDependency('finalhandler');
  }

  static load(browser) {
    if (!browser.config.staticServer) {
      return
    }

    if (browser.config.staticServer === true) {
      browser.config.staticServer = {};
    }

    if (!browser.config.staticServer.folder) {
      const { folder } = browser.config;
      if (!folder) {
        return
      }

      browser.config.staticServer.folder = folder;
    }

    browser.hook('start:before', () => StaticServer.start(browser.config.staticServer, browser.config.quiet));
    browser.hook('close:after', StaticServer.stop);
  }

  static async start(config, quiet) {
    await StaticServer.loadDependencies();

    const host = process.env.HOST || config.host || 'localhost';
    const port = process.env.PORT || config.port || 3000;

    const serve = StaticServer.serveStatic(config.folder);

    const server = http__default['default'].createServer((req, res) => {
      serve(req, res, StaticServer.finalhandler(req, res));
    });

    await new Promise((resolve, reject) => {
      server.on('error', reject);
      server.listen(port, host, () => {
        if (!quiet) {
          // eslint-disable-next-line no-console
          console.info(`tib: Static server started on http://${host}:${port}`);
        }

        config.host = host;
        config.port = port;

        StaticServer.server = server;

        resolve(server);
      });
    });
  }

  static stop() {
    if (StaticServer.server) {
      return new Promise((resolve) => {
        StaticServer.server.close(() => {
          StaticServer.server = undefined;
          resolve();
        });
      })
    }
  }
}

const index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Xvfb: Xvfb,
  BrowserStackLocal: BrowserStackLocal,
  StaticServer: StaticServer
});

/**
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DONT CHANGE ANYTHING MANUALLY
 */

const _interopDefault$1 = i => i.then(m => m.default || m);

const browsers$1 = {
  'browserstack': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index2.js'); })),
  'browserstack/local': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-local.js'); })),
  'chrome': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index4.js'); })),
  'chrome/browserstack': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index5.js'); })),
  'chrome/browserstack/local': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-local2.js'); })),
  'chrome/puppeteer': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-puppeteer.js'); })),
  'chrome/selenium': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-selenium.js'); })),
  'edge': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index7.js'); })),
  'edge/browserstack': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index8.js'); })),
  'edge/browserstack/local': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-local3.js'); })),
  'edge/selenium': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-selenium2.js'); })),
  'firefox': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index9.js'); })),
  'firefox/browserstack': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index10.js'); })),
  'firefox/browserstack/local': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-local4.js'); })),
  'firefox/selenium': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-selenium3.js'); })),
  'ie': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index11.js'); })),
  'ie/browserstack': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index12.js'); })),
  'ie/browserstack/local': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-local5.js'); })),
  'ie/selenium': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-selenium4.js'); })),
  'jsdom': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index13.js'); })),
  'puppeteer': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index6.js'); })),
  'puppeteer/core': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-core.js'); })),
  'safari': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index14.js'); })),
  'safari/browserstack': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index15.js'); })),
  'safari/browserstack/local': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-local6.js'); })),
  'safari/selenium': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-selenium5.js'); })),
  'saucelabs': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index16.js'); })),
  'selenium': () => _interopDefault$1(Promise.resolve().then(function () { return require('./tib-index3.js'); }))
};

class Browser extends Hookable__default['default'] {
  constructor(config = {}) {
    super();

    abstractGuard('Browser', new.target);

    this.config = {
      quiet: false,
      ...config
    };

    this.ready = false;

    if (config.extendPage && typeof config.extendPage === 'function') {
      this.hook('page:after', async (page) => {
        const extendWith = await config.extendPage(page);
        if (extendWith && typeof extendWith === 'object') {
          page.extend(extendWith);
        }
      });
    }

    this.capabilities = {};

    // before browserConfig
    this.config.browserArguments = this.config.browserArguments || [];

    if (this.config.browserConfig) {
      for (const key in this.config.browserConfig) {
        if (key.startsWith('driver') || key.startsWith('provider') || key === 'browserVariant') {
          continue
        }

        if (key === 'staticserver') {
          if (!this.config.staticServer) {
            this.config.staticServer = true;
          }
          continue
        }

        if (key === 'xvfb') {
          if (this.config.browserConfig[key] === 'false' || this.config.browserConfig.headless) {
            continue
          }

          if (!this.config.xvfb) {
            this.config.xvfb = Xvfb.isSupported();
          }

          continue
        }

        const fn = `set${key.charAt(0).toUpperCase()}${key.slice(1)}`;
        if (this[fn]) {
          this[fn](this.config.browserConfig[key]);
        } else {
          console.warn(`browserConfig '${key}' could not be set`); // eslint-disable-line no-console
        }
      }
    }

    if (!this.config.xvfb && this.config.xvfb !== false) {
      this.config.xvfb = Xvfb.isSupported();
    }

    Xvfb.load(this);
    StaticServer.load(this);

    if (isMockedFunction(setTimeout, 'setTimeout')) {
      // eslint-disable-next-line no-console
      console.warn(`Mocked timers detected

The browser probably won't ever start with globally mocked timers. Will try to automatically use real timers on start and set to use fake timers after start. If the browser still hangs and doesn't start, make sure to only mock the global timers after the browser has started `);

      this.hook('start:before', () => enableTimers());
      this.hook('start:after', () => disableTimers());
    }
  }

  static async get(browserString = '', config = {}) {
    const browserConfig = getBrowserConfigFromString(browserString);
    const browserImport = getBrowserImportFromConfig(browserConfig);

    if (!browsers$1[browserImport]) {
      throw new BrowserError(`Unknown browser, no import exists for '${browserImport}'`)
    }

    try {
      // add browserConfig to config
      config.browserConfig = browserConfig;

      const Browser = await browsers$1[browserImport]();

      const browserInstance = new Browser(config);
      await browserInstance.loadDependencies();
      return browserInstance
    } catch (e) {
      if (e instanceof BrowserError) {
        throw e
      } else {
        throw new BrowserError(`Error occured while loading '${browserConfig.browser || browserString}' browser`, e)
      }
    }
  }

  setLogLevel(level) {}

  async loadDependency(dependency) {
    try {
      return await loadDependency(dependency)
    } catch (e) {
      throw new BrowserError(this, e.message)
    }
  }

  _loadDependencies() {}

  async loadDependencies(...args) {
    await this.callHook('dependencies:load');

    await this._loadDependencies(...args);

    await this.callHook('dependencies:loaded');
  }

  getUrl(urlPath) {
    if (this.config.staticServer) {
      const { host, port } = this.config.staticServer;
      return `http://${host}:${port}${urlPath}`
    }

    return `file://${path__default['default'].join(this.config.folder, urlPath)}`
  }

  getCapabilities(capabilities) {
    if (!capabilities) {
      return this.capabilities
    }

    return {
      ...this.capabilities,
      ...capabilities
    }
  }

  getCapability(capability) {
    return this.capabilities[capability]
  }

  addCapability(key, value) {
    this.capabilities[key] = value;
    return this
  }

  addCapabilities(capabilities) {
    this.capabilities = {
      ...this.capabilities,
      ...capabilities
    };
    return this
  }

  setWindow(width, height) {
    if (!height && typeof width === 'object') {
      this.config.window = width;
      return this
    }

    this.config.window = { width, height };
    return this
  }

  getBrowser(name) {
    return this.getCapability('browserName')
  }

  setBrowser(name, version = '') {
    this.addCapability('browserName', name);

    if (version) {
      this.setBrowserVersion(version);
    }

    return this
  }

  setHeadless() {
    this.config.xvfb = false;
    return this
  }

  getBrowserVersion() { return undefined }

  setBrowserVersion() { return this }

  setOs(...args) { return this.setOS(...args) }

  setOsVersion(...args) { return this.setOSVersion(...args) }

  setOS() { return this }

  setOSVersion() { return this }

  setDevice() { return this }

  isReady() {
    return this.ready
  }

  _start() {}

  _close() {}

  _page() {}

  async start(capabilities, ...args) {
    await this.callHook('start:before');

    try {
      await this._start(capabilities, ...args);

      await this.callHook('start:after', this.driver);

      this.ready = true;

      onExit__default['default'](() => this.close());

      return this
    /* istanbul ignore next */
    } catch (e) {
      await this.close();

      throw new BrowserError(e)
    }
  }

  async close(...args) {
    await this.callHook('close:before');

    await this._close(...args);

    await this.callHook('close:after');
  }

  async page(...args) {
    await this.callHook('page:before');

    const page = await this._page(...args);

    await this.callHook('page:after', page);

    return page
  }
}

async function createBrowser(str, conf, autoStart = true) {
  const instance = Browser.get(str, conf);
  if (!autoStart) {
    return instance
  }

  return (await instance).start()
}

function browser(...args) {
  /* istanbul ignore next */
  console.warn('DeprecationWarning: \'browser\' has been renamed to \'createBrowser\''); // eslint-disable-line no-console
  /* istanbul ignore next */
  return createBrowser(...args)
}

exports.Browser = Browser;
exports.BrowserError = BrowserError;
exports.BrowserStackLocal = BrowserStackLocal;
exports.abstractGuard = abstractGuard;
exports.browser = browser;
exports.createBrowser = createBrowser;
exports.createCacheKey = createCacheKey;
exports.createPageFunctions = createPageFunctions;
exports.index = index;
