{"code":"import { markRaw } from 'vue';\r\nimport { isArray, isObject, isPlainObject } from '@vue/shared';\r\nimport { clone, pluck } from '../utils';\r\nimport { IS_PROXY, PROXY_SOURCES, PROXY_TARGET, RESOLVE_CONTEXT } from './constants';\r\nimport { recompute } from './recompute';\r\nexport const createProxy = (context, target, resolveContext, pathSegments = []) => {\r\n    const handler = createHandler(context, resolveContext, pathSegments);\r\n    const proxy = markRaw(new Proxy(target, handler));\r\n    if (!pathSegments.length && context.sources) {\r\n        context.sources.push(proxy);\r\n    }\r\n    return proxy;\r\n};\r\nexport const createHandler = (context, resolveContext, pathSegments = []) => ({\r\n    get: (target, key, receiver) => {\r\n        if (key === IS_PROXY) {\r\n            return true;\r\n        }\r\n        if (key === PROXY_SOURCES) {\r\n            return context.sources;\r\n        }\r\n        if (key === PROXY_TARGET) {\r\n            return target;\r\n        }\r\n        if (key === RESOLVE_CONTEXT) {\r\n            return resolveContext;\r\n        }\r\n        let value = Reflect.get(target, key, receiver);\r\n        if (!isObject(value)) {\r\n            return value;\r\n        }\r\n        // Also return a merge proxy for nested objects\r\n        if (!value[IS_PROXY]) {\r\n            const keyPath = [...pathSegments, key];\r\n            value = createProxy(context, value, resolveContext, keyPath);\r\n            Reflect.set(target, key, value);\r\n        }\r\n        return value;\r\n    },\r\n    set: (target, key, value) => {\r\n        const success = Reflect.set(target, key, value);\r\n        // console.warn(success, 'PROXY SET\\nkey:', key, '\\nvalue:', value, '\\npath:', pathSegments, '\\ntarget:', isArray(target), target, '\\ncontext:\\n', context)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let hasArrayParent = false;\r\n            let { sources: proxies, active } = context;\r\n            let activeSegmentKey;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                proxies = pluck(proxies, segment);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                if (isArray(active)) {\r\n                    hasArrayParent = true;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            if (hasArrayParent) {\r\n                // TODO: fix that we dont have to recompute the full merged object\r\n                // we should only have to recompute the branch that has changed\r\n                // but there is an issue here with supporting both arrays of strings\r\n                // as collections (parent vs parent of parent we need to trigger the\r\n                // update from)\r\n                recompute(context);\r\n                return success;\r\n            }\r\n            else if (isPlainObject(value)) {\r\n                // if an object was assigned to this key make sure to recompute all\r\n                // of its individual properies\r\n                recompute(context, pathSegments);\r\n                return success;\r\n            }\r\n            let keyContexts = [];\r\n            let keySources;\r\n            if (isArrayItem) {\r\n                keySources = proxies;\r\n                keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n            }\r\n            else {\r\n                keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n            }\r\n            let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n            // Ensure to clone if value is an object, cause sources is an array of\r\n            // the sourceProxies and not the sources so we could trigger an endless loop when\r\n            // updating a prop on an obj as the prop on the active object refers to\r\n            // a prop on a proxy\r\n            if (isPlainObject(resolved)) {\r\n                resolved = clone(resolved);\r\n            }\r\n            // console.log('SET VALUE', isArrayItem, key, '\\nresolved:\\n', resolved, '\\nsources:\\n', context.sources, '\\nactive:\\n', active, Object.keys(active))\r\n            if (isArrayItem && activeSegmentKey) {\r\n                active[activeSegmentKey] = resolved;\r\n            }\r\n            else {\r\n                active[key] = resolved;\r\n            }\r\n        }\r\n        //    console.log('CONTEXT.ACTIVE', context.active, '\\nparent:\\n', target)\r\n        return success;\r\n    },\r\n    deleteProperty: (target, key) => {\r\n        const success = Reflect.deleteProperty(target, key);\r\n        // console.warn('PROXY DELETE\\nkey:', key, '\\npath:', pathSegments, '\\nparent:', isArray(target), target)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let activeSegmentKey;\r\n            let proxies = context.sources;\r\n            let active = context.active;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                // @ts-ignore\r\n                proxies = proxies.map(proxy => proxy && proxy[segment]);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            // Check if the key still exists in one of the sourceProxies,\r\n            // if so resolve the new value, if not remove the key\r\n            if (proxies.some(proxy => proxy && (key in proxy))) {\r\n                let keyContexts = [];\r\n                let keySources;\r\n                if (isArrayItem) {\r\n                    keySources = proxies;\r\n                    keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n                }\r\n                else {\r\n                    keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n                }\r\n                let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n                if (isPlainObject(resolved)) {\r\n                    resolved = clone(resolved);\r\n                }\r\n                // console.log('SET VALUE', resolved)\r\n                if (isArrayItem && activeSegmentKey) {\r\n                    active[activeSegmentKey] = resolved;\r\n                }\r\n                else {\r\n                    active[key] = resolved;\r\n                }\r\n            }\r\n            else {\r\n                delete active[key];\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n});\r\n//# sourceMappingURL=proxy.js.map","references":["/tmp/b/vue-meta/node_modules/vue/dist/vue.d.ts","/tmp/b/vue-meta/node_modules/@vue/shared/dist/shared.d.ts","/tmp/b/vue-meta/src/utils/index.ts","/tmp/b/vue-meta/src/object-merge/constants.ts","/tmp/b/vue-meta/src/object-merge/recompute.ts","/tmp/b/vue-meta/src/object-merge/index.ts"],"map":"{\"version\":3,\"file\":\"proxy.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/object-merge/proxy.ts\"],\"names\":[],\"mappings\":\"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\"}","dtsmap":{"name":"/tmp/b/vue-meta/node_modules/.rts2_cache/placeholder/src/object-merge/proxy.d.ts.map","writeByteOrderMark":false,"text":"{\"version\":3,\"file\":\"proxy.d.ts\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/object-merge/proxy.ts\"],\"names\":[],\"mappings\":\"AAKA,OAAO,KAAK,EAAE,YAAY,EAAE,WAAW,EAAqB,YAAY,EAAE,cAAc,EAAE,MAAM,GAAG,CAAA;AAEnG,eAAO,MAAM,WAAW,uFAAwF,cAAc,gDAS7H,CAAA;AAED,eAAO,MAAM,aAAa,gDAAiD,cAAc,8DAkLvF,CAAA\"}"},"dts":{"name":"/tmp/b/vue-meta/node_modules/.rts2_cache/placeholder/src/object-merge/proxy.d.ts","writeByteOrderMark":false,"text":"import type { MergeContext, MergeSource, PathSegments, ResolveContext } from '.';\r\nexport declare const createProxy: <T extends Record<string, any>>(context: MergeContext<T>, target: T, resolveContext: ResolveContext, pathSegments?: PathSegments) => MergeSource<T>;\r\nexport declare const createHandler: <T>(context: MergeContext<T>, resolveContext: ResolveContext, pathSegments?: PathSegments) => ProxyHandler<MergeSource<T>>;\r\n//# sourceMappingURL=proxy.d.ts.map"}}
